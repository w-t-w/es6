/**
 * react 的特性
 * 1. 数据驱动
 * 2. JSX 语法糖动态声明更加灵活
 * 3. Virtual DOM 虚拟 DOM 与 Diff 算法配合,可保证性能
 * 4. Fiber 启用新的数据结构和新的任务调度,令 react 的性能更加出色
 */
/**
 * 生命周期
 * 1. 创建阶段:
 *    constructor(初始化组件)
 *    getDerivedStateFromProps(用于合并组件外的 props 至组件内 state,不推荐使用)
 *    render(是 react 组件内部唯一描述 UI 的方法,必须设置)
 *    componentDidMount(在首次 react 组件渲染更新完成之后,要执行的如异步 HTTP 请求等的步骤)
 * 2. 更新阶段:
 *    getDerivedStateFromProps(用于合并组件外的 props 至组件内 state,不推荐使用)
 *    shouldComponentUpdate(用于判断 react 组件是否可以实行渲染更新)
 *    getSnapShotBeforeUpdate(用于在 react 组件渲染更新之前,要实行的一些统计计算)
 *    render(是 react 组件内部唯一描述 UI 的方法,必须设置)
 *    componentDidUpdate(用于在 react 组件渲染更新之后,要执行的一些操作)
 * 3. 卸载阶段:
 *    componentWillUnmount(用于在 react 组件卸载时,要实行的资源释放等的操作,用于资源释放)
 */
/**
 * Diff 算法
 * 1. 时间复杂度
 *    O(n^3) -> O(n),如此巨大的性能提升,是建立在 react 实际上只实行同层兄弟节点之间的对比,不实行跨层节点对比
 * 2. 节点变化
 *    1) 属性变化
 *    2) 类型变化
 *    3) 位置变化
 *    4) 跨层移动
 *    对于上述的四种变化,react 对其的处理是比较简单粗暴的,不会对其实行跨层检索验证,而只是实行简单的增加、删除以及替换的操作,这也是基于 Virtual DOM 虚拟 DOM 的结构一般比较稳定,基本上不会出现跨层移动的情况,大多都是同层的兄弟节点之间的属性、位置以及类型的变化
 * 3. key
 *    key 适用于那些需要频繁变换位置的 react 组件节点,其稳定的类型指向可保证其不会被剃掉删除,更不会额外增加 DOM 操作的开销,而只是替换位置
 */
 /** HOC
 *    1. 属性代理
 *    2. 反向继承
 *    3. 渲染劫持
 */
 /**
 * 5. class 与 hooks
 *    区别
 *    class
 *    很少使用 class 的一些特性: 只可使用 new 构造调用、类的继承与派生
 *    class react 组件的复用极其复杂,必须基于 HOC 高阶组件,产生了冗余的逻辑,创建了不必要的组件节点
 *    class react 组件会将所有的业务逻辑全部分散在不同的生命周期内,更加注重技术部分的逻辑
 *    hooks
 *    hooks react 组件的复用更加简洁,不会产生额外的逻辑,更不会创建多余的组件节点
 *    hooks react 组件更加关注于技术和业务的彻底分离
 */
 /**
 * 6. hooks
 *    useState: 用于维持组件的状态
 *              当组件拥有了状态,那么每一次使用都会存在恢复状态的过程
 *    useEffect: 用于利用副作用
 *               其包含了基于 class react 组件的生命周期: componentDidMount、componentDidUpdate、componentWillUnmount
 *               在依赖项数组内的数组元素发生变化时,回调函数才会执行
 *               依赖项数组内的数组元素必须在回调函数内使用,这样才具有意义
 *               依赖项数组必须是一个常量数组,不可为一个变量
 *               依赖项数组内的数组元素不可为引用类型对象
 *    useCallback: 用于缓存回调函数
 *                 避免不必要的创建回调函数以及 react 组件的渲染更新
 *    useMemo: 用于缓存计算结果
 *             避免不必要的计算过程以及 react 组件的渲染更新
 *             可模拟 useCallback
 *    useRef: 用于在多次渲染之间存储、共享数据
 *            大多用于存储 setTimeout、setInterval 产生的id,再就是用于存储 DOM 对象
 *    useContext: 用于实现数据绑定,在祖先节点的数据发生变化时,子孙节点使用到此数据的会自动渲染更新
 *    限制:
 *         hooks 只可在函数组件内部以及其他 hooks 内使用
 *         hooks 只可在函数组件的顶层作用域使用,不可在循环、条件判断以及嵌套函数中使用
 *    混合:
 *         要想在 class react 组件中使用 hooks,通过 HOC 高阶组件属性代理即可
 */
 /**
 * 7. fiber
 *    概念: 由于 react 处理组件渲染更新的过程是同步的,那么当同一时间内,存在大量的 react 组件渲染更新时,JS 线程处理的时间可能会比较长,在这期间浏览器是不会对任何事件做出响应的,因为 JS 线程和 GUI 线程是互斥的.fiber 就是用于解决此类问题的,它会将长时间的同步任务分割成多个小的同步任务,并启用新的任务调度和新的数据结构
 *    特性: 新的任务调度
 *         当遇到高优先级的任务时,会先将浏览器让出来响应,等浏览器空闲了再继续执行
 *         新的数据结构
 *         采用链表结构,可随时中断,也可接回重连
 *         child: 父组件指向第一个子组件的指针
 *         return: 所有子组件都存在的指向父组件的指针
 *         sibling: 在第一个子组件之后,指向兄弟组件的指针
 */